diff --git a/dist/index.d.ts b/dist/index.d.ts
index 48e2f6263c6ee4c75d7e5c28733e64f6ebe92200..00d0729c4a3cbf9a48e8e1e962c7e2b256b75eba 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -7,6 +7,7 @@ declare const openaiCompatibleProviderOptions: z.ZodObject<{
     user: z.ZodOptional<z.ZodString>;
     reasoningEffort: z.ZodOptional<z.ZodString>;
     textVerbosity: z.ZodOptional<z.ZodString>;
+    sendReasoning: z.ZodOptional<z.ZodBoolean>;
 }, z.core.$strip>;
 type OpenAICompatibleProviderOptions = z.infer<typeof openaiCompatibleProviderOptions>;
 
diff --git a/dist/index.js b/dist/index.js
index da237bb35b7fa8e24b37cd861ee73dfc51cdfc72..88349c614a69a268a2e4f3b157cb5e328ca1d347 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -41,7 +41,7 @@ function getOpenAIMetadata(message) {
   var _a, _b;
   return (_b = (_a = message == null ? void 0 : message.providerOptions) == null ? void 0 : _a.openaiCompatible) != null ? _b : {};
 }
-function convertToOpenAICompatibleChatMessages(prompt) {
+function convertToOpenAICompatibleChatMessages({prompt, options}) {
   const messages = [];
   for (const { role, content, ...message } of prompt) {
     const metadata = getOpenAIMetadata({ ...message });
@@ -91,6 +91,7 @@ function convertToOpenAICompatibleChatMessages(prompt) {
       }
       case "assistant": {
         let text = "";
+        let reasoning_text = "";
         const toolCalls = [];
         for (const part of content) {
           const partMetadata = getOpenAIMetadata(part);
@@ -99,6 +100,12 @@ function convertToOpenAICompatibleChatMessages(prompt) {
               text += part.text;
               break;
             }
+            case "reasoning": {
+              if (options.sendReasoning) {
+                reasoning_text += part.text;
+              }
+              break;
+            }
             case "tool-call": {
               toolCalls.push({
                 id: part.toolCallId,
@@ -116,6 +123,7 @@ function convertToOpenAICompatibleChatMessages(prompt) {
         messages.push({
           role: "assistant",
           content: text,
+          reasoning_content: reasoning_text || undefined,
           tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
           ...metadata
         });
@@ -200,7 +208,9 @@ var openaiCompatibleProviderOptions = import_v4.z.object({
   /**
    * Controls the verbosity of the generated text. Defaults to `medium`.
    */
-  textVerbosity: import_v4.z.string().optional()
+  textVerbosity: import_v4.z.string().optional(),
+  sendReasoning: import_v4.z.boolean().optional(),
+  strictJsonSchema: z.boolean().optional()
 });
 
 // src/openai-compatible-error.ts
@@ -225,7 +235,8 @@ var defaultOpenAICompatibleErrorStructure = {
 var import_provider2 = require("@ai-sdk/provider");
 function prepareTools({
   tools,
-  toolChoice
+  toolChoice,
+  strictJsonSchema
 }) {
   tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
   const toolWarnings = [];
@@ -242,7 +253,8 @@ function prepareTools({
         function: {
           name: tool.name,
           description: tool.description,
-          parameters: tool.inputSchema
+          parameters: tool.inputSchema,
+          strict: strictJsonSchema
         }
       });
     }
@@ -378,7 +390,7 @@ var OpenAICompatibleChatLanguageModel = class {
         reasoning_effort: compatibleOptions.reasoningEffort,
         verbosity: compatibleOptions.textVerbosity,
         // messages:
-        messages: convertToOpenAICompatibleChatMessages(prompt),
+        messages: convertToOpenAICompatibleChatMessages({prompt, options: compatibleOptions}),
         // tools:
         tools: openaiTools,
         tool_choice: openaiToolChoice
@@ -421,6 +433,17 @@ var OpenAICompatibleChatLanguageModel = class {
         text: reasoning
       });
     }
+    if (choice.message.images) {
+      for (const image of choice.message.images) {
+        const match1 = image.image_url.url.match(/^data:([^;]+)/)
+        const match2 = image.image_url.url.match(/^data:[^;]*;base64,(.+)$/);
+        content.push({
+          type: 'file',
+          mediaType: match1 ? (match1[1] ?? 'image/jpeg') : 'image/jpeg',
+          data: match2 ? match2[1] : image.image_url.url,
+        });
+      }
+    }
     if (choice.message.tool_calls != null) {
       for (const toolCall of choice.message.tool_calls) {
         content.push({
@@ -598,6 +621,17 @@ var OpenAICompatibleChatLanguageModel = class {
                 delta: delta.content
               });
             }
+            if (delta.images) {
+              for (const image of delta.images) {
+                const match1 = image.image_url.url.match(/^data:([^;]+)/)
+                const match2 = image.image_url.url.match(/^data:[^;]*;base64,(.+)$/);
+                controller.enqueue({
+                  type: 'file',
+                  mediaType: match1 ? (match1[1] ?? 'image/jpeg') : 'image/jpeg',
+                  data: match2 ? match2[1] : image.image_url.url,
+                });
+              }
+            }
             if (delta.tool_calls != null) {
               for (const toolCallDelta of delta.tool_calls) {
                 const index = toolCallDelta.index;
@@ -765,6 +799,14 @@ var OpenAICompatibleChatResponseSchema = import_v43.z.object({
               arguments: import_v43.z.string()
             })
           })
+        ).nullish(),
+        images: import_v43.z.array(
+          import_v43.z.object({
+            type: import_v43.z.literal('image_url'),
+            image_url: import_v43.z.object({
+              url: import_v43.z.string(),
+            })
+          })
         ).nullish()
       }),
       finish_reason: import_v43.z.string().nullish()
@@ -795,6 +837,14 @@ var createOpenAICompatibleChatChunkSchema = (errorSchema) => import_v43.z.union(
                 arguments: import_v43.z.string().nullish()
               })
             })
+          ).nullish(),
+          images: import_v43.z.array(
+            import_v43.z.object({
+              type: import_v43.z.literal('image_url'),
+              image_url: import_v43.z.object({
+                url: import_v43.z.string(),
+              })
+            })
           ).nullish()
         }).nullish(),
         finish_reason: import_v43.z.string().nullish()
diff --git a/dist/index.mjs b/dist/index.mjs
index a809a7aa0e148bfd43e01dd7b018568b151c8ad5..fca65c04000ce4c01fb90e93326ac179c2378055 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -23,7 +23,7 @@ function getOpenAIMetadata(message) {
   var _a, _b;
   return (_b = (_a = message == null ? void 0 : message.providerOptions) == null ? void 0 : _a.openaiCompatible) != null ? _b : {};
 }
-function convertToOpenAICompatibleChatMessages(prompt) {
+function convertToOpenAICompatibleChatMessages({prompt, options}) {
   const messages = [];
   for (const { role, content, ...message } of prompt) {
     const metadata = getOpenAIMetadata({ ...message });
@@ -73,6 +73,7 @@ function convertToOpenAICompatibleChatMessages(prompt) {
       }
       case "assistant": {
         let text = "";
+        let reasoning_text = "";
         const toolCalls = [];
         for (const part of content) {
           const partMetadata = getOpenAIMetadata(part);
@@ -81,6 +82,12 @@ function convertToOpenAICompatibleChatMessages(prompt) {
               text += part.text;
               break;
             }
+            case "reasoning": {
+              if (options.sendReasoning) {
+                reasoning_text += part.text;
+              }
+              break;
+            }
             case "tool-call": {
               toolCalls.push({
                 id: part.toolCallId,
@@ -98,6 +105,7 @@ function convertToOpenAICompatibleChatMessages(prompt) {
         messages.push({
           role: "assistant",
           content: text,
+          reasoning_content: reasoning_text || undefined,
           tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
           ...metadata
         });
@@ -182,7 +190,9 @@ var openaiCompatibleProviderOptions = z.object({
   /**
    * Controls the verbosity of the generated text. Defaults to `medium`.
    */
-  textVerbosity: z.string().optional()
+  textVerbosity: z.string().optional(),
+  sendReasoning: z.boolean().optional(),
+  strictJsonSchema: z.boolean().optional()
 });
 
 // src/openai-compatible-error.ts
@@ -209,7 +219,8 @@ import {
 } from "@ai-sdk/provider";
 function prepareTools({
   tools,
-  toolChoice
+  toolChoice,
+  strictJsonSchema
 }) {
   tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
   const toolWarnings = [];
@@ -226,7 +237,8 @@ function prepareTools({
         function: {
           name: tool.name,
           description: tool.description,
-          parameters: tool.inputSchema
+          parameters: tool.inputSchema,
+          strict: strictJsonSchema
         }
       });
     }
@@ -362,7 +374,7 @@ var OpenAICompatibleChatLanguageModel = class {
         reasoning_effort: compatibleOptions.reasoningEffort,
         verbosity: compatibleOptions.textVerbosity,
         // messages:
-        messages: convertToOpenAICompatibleChatMessages(prompt),
+        messages: convertToOpenAICompatibleChatMessages({prompt, options: compatibleOptions}),
         // tools:
         tools: openaiTools,
         tool_choice: openaiToolChoice
@@ -405,6 +417,17 @@ var OpenAICompatibleChatLanguageModel = class {
         text: reasoning
       });
     }
+    if (choice.message.images) {
+      for (const image of choice.message.images) {
+        const match1 = image.image_url.url.match(/^data:([^;]+)/)
+        const match2 = image.image_url.url.match(/^data:[^;]*;base64,(.+)$/);
+        content.push({
+          type: 'file',
+          mediaType: match1 ? (match1[1] ?? 'image/jpeg') : 'image/jpeg',
+          data: match2 ? match2[1] : image.image_url.url,
+        });
+      }
+    }
     if (choice.message.tool_calls != null) {
       for (const toolCall of choice.message.tool_calls) {
         content.push({
@@ -582,6 +605,17 @@ var OpenAICompatibleChatLanguageModel = class {
                 delta: delta.content
               });
             }
+            if (delta.images) {
+              for (const image of delta.images) {
+                const match1 = image.image_url.url.match(/^data:([^;]+)/)
+                const match2 = image.image_url.url.match(/^data:[^;]*;base64,(.+)$/);
+                controller.enqueue({
+                  type: 'file',
+                  mediaType: match1 ? (match1[1] ?? 'image/jpeg') : 'image/jpeg',
+                  data: match2 ? match2[1] : image.image_url.url,
+                });
+              }
+            }
             if (delta.tool_calls != null) {
               for (const toolCallDelta of delta.tool_calls) {
                 const index = toolCallDelta.index;
@@ -749,6 +783,14 @@ var OpenAICompatibleChatResponseSchema = z3.object({
               arguments: z3.string()
             })
           })
+        ).nullish(),
+        images: z3.array(
+          z3.object({
+            type: z3.literal('image_url'),
+            image_url: z3.object({
+              url: z3.string(),
+            })
+          })
         ).nullish()
       }),
       finish_reason: z3.string().nullish()
@@ -779,6 +821,14 @@ var createOpenAICompatibleChatChunkSchema = (errorSchema) => z3.union([
                 arguments: z3.string().nullish()
               })
             })
+          ).nullish(),
+          images: z3.array(
+            z3.object({
+              type: z3.literal('image_url'),
+              image_url: z3.object({
+                url: z3.string(),
+              })
+            })
           ).nullish()
         }).nullish(),
         finish_reason: z3.string().nullish()
